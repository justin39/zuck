#!/bin/env python3
import curses
import curses.textpad
import threading
import logging.config
from fbchat import Client
from fbchat.models import *
from sys import exit
from sys import stderr
from enum import Enum

class Mode(Enum):
    CHAT = 0
    NAVI = 1

# Globals
mode = Mode.CHAT
name_cache = {}
client = None

class ChatClient(Client):
    chat = None
    def onMessage(self, mid, author_id, message_object, thread_id, thread_type, ts, metadata, msg, **kwargs):
        if not self.chat.scrolling and thread_id == self.chat.tid:
            self.chat.display_chat()
        else:
            self.chat.update_bar()

class ChatState:
    def __init__(self, chatwin, bar):
        self.scrolling = False
        self.chatwin = chatwin
        self.bar = bar
        self.threads = client.fetchThreadList()
        self.idx = 0

    def display_chat(self, timestamp=None):
        messages = client.fetchThreadMessages(self.threads[self.idx].uid, limit=20, before=timestamp)
        messages.reverse()
        for msg in messages:
            self.chatwin.window.addstr(get_name(msg.author) + ":\n", curses.A_BOLD)
            if msg.text:
                self.chatwin.window.addstr(msg.text + "\n\n")
            elif msg.sticker:
                self.chatwin.window.addstr('[' + msg.sticker.label + ']\n\n')
        self.chatwin.refresh()

    def update_bar(self):
        self.bar.window.erase()
        self.threads = client.fetchThreadList()
        unread = client.fetchUnread()
        written = 0
        i = 0
        while written < self.bar.width:
            attr = 0
            if self.threads[i].uid == self.threads[self.idx].uid:
                attr = curses.A_UNDERLINE | curses.color_pair(2)
                self.idx = i
            if self.threads[i].uid in unread:
                attr |= curses.A_BOLD
            self.bar.window.addstr(self.threads[i].name, attr)
            i += 1
            written += len(self.threads[i].name)
            if len(self.threads[i].name) + 3 + written > self.bar.width:
                break
            else:
                self.bar.window.addstr(' | ')
                written += 3
        self.bar.refresh()

    def prev_thread(self):
        if self.idx == 0:
            return
        self.idx -= 1
        self.update_bar()
        self.display_chat()

    def next_thread(self):
        if self.idx == 19:
            return
        self.idx += 1
        self.update_bar()
        self.display_chat()

class Panel:
    def __init__(self, height, width, y, x, outline = True):
        self.height = height
        self.width = width
        self.y = y
        self.x = x
        if outline:
            self.box = curses.newwin(height, width, y, x)
            self.window = curses.newwin(height - 2, width - 2, y + 1, x + 1)
        else:
            self.window = curses.newwin(height, width, y, x)
        self.active = False
        self.outline = outline

    def update(self):
        self.window.redrawwin()
        if self.outline:
            if self.active:
                self.box.attrset(curses.color_pair(1))
            self.box.box()
            self.box.noutrefresh()
            self.box.attrset(0)
        self.window.noutrefresh()

    def refresh(self):
        self.update()
        curses.doupdate()

def login(usr, pwd):
    try:
        return ChatClient(usr, pwd, max_tries=3, logging_level=logging.CRITICAL)
        # return ChatClient(usr, pwd, max_tries=3)
    except FBchatException as e:
        stderr.write("Failed to login!")
        sys.exit(1)
    except FBchatUserError:
        stderr.write("Incorrect credentials!")
        sys.exit(1)

def listen_thread():
    client.listen()

def get_name(uid):
    if uid not in name_cache:
        retval = client.fetchThreadInfo(uid)[uid]
        name_cache[uid] = retval.name
    return name_cache[uid]

def validate(ch):
    return ch
    if ch == 10 or ch == 13 or ch == curses.KEY_ENTER:
        return 7

def chat(stdscr):
    curses.start_color()
    curses.init_pair(1, curses.COLOR_CYAN, curses.COLOR_BLACK)
    curses.init_pair(2, curses.COLOR_YELLOW, curses.COLOR_BLACK)
    stdscr.clear()
    curses.noecho()
    curses.cbreak()
    stdscr.keypad(True)
    curses.curs_set(False)

    mode = Mode.NAVI

    lines = curses.LINES - 1
    cols = curses.COLS
    height = lines - 3
    width = cols//3

    # Initial chat
    thlist = client.fetchThreadList(limit=1)

    win = Panel(height, width, 2, 0)
    win.active = True
    win.window.idlok(True)
    win.window.scrollok(True)

    # Listening thread
    lthread = threading.Thread(target=listen_thread)
    lthread.daemon = True
    lthread.start()

    # Next panel
    panel = Panel(height, width, 2, width+3)

    # Text input
    textwin = Panel(height//3, width - 2, height - height//3 + 1, width + 4)
    textbox = curses.textpad.Textbox(textwin.window)

    # Status bar
    bar = Panel(2, cols, 0, 0, False)

    cs = ChatState(win, bar)
    client.chat = cs
    cs.display_chat()
    cs.update_bar()

    while (True):
        bar.update()
        win.update()
        panel.update()
        textwin.update()
        curses.doupdate()
        if mode == Mode.CHAT:
            msg = textbox.edit(validate)
        elif mode == Mode.NAVI:
            ch = win.window.getch()
            if ch == ord('q'):
                return
            elif ch == ord('i'):
                mode = Mode.CHAT
                win.active = False
                textwin.active = True
            elif ch == ord('h') or ch == curses.KEY_LEFT:
                cs.prev_thread()
            elif ch == ord('l') or ch == curses.KEY_RIGHT:
                cs.next_thread()

if __name__ == '__main__':
    from sys import argv
    import getpass
    username = ''
    password = ''
    if len(argv) > 1:
        username = argv[1]
    else:
        username = input('Username: ')
    password = getpass.getpass('Password: ')
    client = login(username, password)
    print("Successfully logged in as", username)
    print("Starting zuck...")
    curses.wrapper(chat)
    client.logout()
