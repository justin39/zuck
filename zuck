#!/bin/env python3
import curses
import curses.textpad
import threading
import logging.config
import textwrap
from fbchat import Client
from fbchat.models import *
from sys import exit
from sys import stderr
from enum import Enum

class Mode(Enum):
    CHAT = 0
    NAVI = 1

# Globals
name_cache = {}
client = None
mode = Mode.NAVI
THREAD_MAX = 20

class ChatClient(Client):
    def __init__(self, *args, **kwargs):
        super(ChatClient, self).__init__(*args, **kwargs)
        self.scrolling = False
        self.w_chat = None
        self.w_bar = None
        self.w_text = None
        self.textbox = None
        self.threads = None
        self.current = 0

    def init_chat(self):
        self.threads = client.fetchThreadList()
        lines = curses.LINES - 1
        cols = curses.COLS
        height = lines - 3
        width = cols//3

        # Chat window
        self.w_chat = Panel(height, width, 2, 0)
        self.w_chat.active = True
        self.w_chat.window.idlok(True)
        self.w_chat.window.scrollok(True)

        # Status bar
        self.w_bar = Panel(2, cols, 0, 0, False)

        # Text input
        self.w_text = Panel(4, width - 4, height - 4, width + 5)
        self.textbox = curses.textpad.Textbox(self.w_text.window)
        self.w_text.window.scrollok(True)

        self.update_bar()
        self.display_chat()


    def onMessage(self, mid, author_id, message_object, thread_id, thread_type, ts, metadata, msg, **kwargs):
        if not self.scrolling and thread_id == self.threads[self.current].uid:
            self.display_chat()
        else:
            self.update_bar()

    def display_chat(self, timestamp=None):
        messages = self.fetchThreadMessages(self.threads[self.current].uid, limit=THREAD_MAX, before=timestamp)
        messages.reverse()
        for msg in messages:
            attr = 0
            if msg.author == client.uid:
                attr = curses.color_pair(5)
            self.w_chat.window.addstr(get_name(msg.author) + ":\n", attr | curses.A_BOLD)
            if msg.author == client.uid:
                attr = curses.color_pair(4)
            if msg.text:
                self.w_chat.window.addstr(msg.text + "\n\n", attr)
            if msg.attachments:
                for a in msg.attachments:
                    url = client.fetchImageUrl(a.uid)
                    self.w_chat.window.addstr(url + "\n")
            if msg.sticker:
                self.w_chat.window.addstr('[' + msg.sticker.url + ']\n\n', attr)
        self.w_chat.refresh()
        self.w_text.refresh()

    def update_bar(self):
        tid = self.threads[self.current].uid
        self.w_bar.window.erase()
        self.threads = self.fetchThreadList()
        unread = client.fetchUnread()
        written = 0
        i = 0
        while written < self.w_bar.width:
            attr = 0
            if self.threads[i].uid == tid:
                attr = curses.A_UNDERLINE | curses.color_pair(2)
                self.current = i
            if self.threads[i].uid in unread:
                attr |= curses.A_BOLD
            self.w_bar.window.addstr(self.threads[i].name, attr)
            i += 1
            written += len(self.threads[i].name)
            if len(self.threads[i].name) + 3 + written > self.w_bar.width:
                break
            else:
                self.w_bar.window.addstr(' | ')
                written += 3
        self.w_bar.refresh()
        self.w_text.refresh()

    def prev_thread(self, n=0):
        n = max(1, n)
        self.current = max(0, self.current - n)
        self.markAsRead(self.threads[self.current].uid)
        self.update_bar()
        self.display_chat()

    def next_thread(self, n=0):
        n = max(1, n)
        self.current = min(self.current + n, THREAD_MAX)
        self.markAsRead(self.threads[self.current].uid)
        self.update_bar()
        self.display_chat()

    def getin(self):
        if mode == Mode.CHAT:
            self.textbox.edit(validate)
            return self.textbox.gather()
        elif mode == Mode.NAVI:
            return self.w_chat.window.getch()

    def clear_textbox(self):
        self.w_text.window.erase()

    def update_all(self):
        self.w_bar.update()
        self.w_chat.update()
        self.w_text.update()

    def message(self, msg):
        self.send(Message(text=msg), thread_id=self.threads[self.current].uid, thread_type=self.threads[self.current].type)

class Panel:
    def __init__(self, height, width, y, x, outline = True):
        self.height = height
        self.width = width
        self.y = y
        self.x = x
        if outline:
            self.box = curses.newwin(height, width, y, x)
            self.window = curses.newwin(height - 2, width - 2, y + 1, x + 1)
        else:
            self.window = curses.newwin(height, width, y, x)
        self.active = False
        self.outline = outline

    def update(self):
        self.window.redrawwin()
        if self.outline:
            if self.active:
                self.box.attrset(curses.color_pair(1))
            self.box.box()
            self.box.noutrefresh()
            self.box.attrset(0)
        self.window.noutrefresh()

    def refresh(self):
        self.update()
        curses.doupdate()

def login(usr, pwd):
    try:
        return ChatClient(usr, pwd, max_tries=1, logging_level=logging.CRITICAL)
    except FBchatException as e:
        stderr.write("Failed to login!")
        sys.exit(1)
    except FBchatUserError:
        stderr.write("Incorrect credentials!")
        sys.exit(1)

def listen_thread():
    client.listen()

def get_name(uid):
    if uid not in name_cache:
        retval = client.fetchThreadInfo(uid)[uid]
        name_cache[uid] = retval.name
    return name_cache[uid]

def validate(ch):
    global mode

    if ch == 27:
        mode = Mode.NAVI
        return 7
    elif ch == 10 or ch == 13 or ch == curses.KEY_ENTER:
        return 7
    else:
        return ch

def chat(stdscr):
    global mode
    curses.start_color()
    curses.use_default_colors()
    curses.init_pair(1, curses.COLOR_CYAN, -1)
    curses.init_pair(2, curses.COLOR_YELLOW, -1)
    curses.init_pair(3, curses.COLOR_RED, -1)
    curses.init_pair(4, 25, -1)
    curses.init_pair(5, 27, -1)
    stdscr.clear()
    curses.noecho()
    curses.cbreak()
    stdscr.keypad(True)

    lines = curses.LINES - 1
    cols = curses.COLS
    height = lines - 3
    width = cols//3

    client.init_chat()

    # Draw box for aesthetics
    box = Panel(height, width, 2, width+3)
    box.update()

    # Listening thread
    lthread = threading.Thread(target=listen_thread)
    lthread.daemon = True
    lthread.start()

    acc = '0'

    while (True):
        client.update_all()
        curses.doupdate()
        out = client.getin()
        if mode == Mode.CHAT and len(out) > 0:
            client.message(out)
            client.display_chat()
            client.clear_textbox()
        elif mode == Mode.NAVI:
            client.w_chat.active = True
            client.w_text.active = False
            if type(out) is int:
                out = chr(out)

            if out == 'q':
                return
            elif out == 'i':
                mode = Mode.CHAT
                client.w_chat.active = False
                client.w_text.active = True
                client.w_text.window.clear()
            elif out == 'h' or out == curses.KEY_LEFT:
                client.prev_thread(int(acc))
            elif out == 'l' or out == curses.KEY_RIGHT:
                client.next_thread(int(acc))
            elif out.isdigit():
                acc += out
            if not out.isdigit():
                acc = '0'

if __name__ == '__main__':
    from sys import argv
    import getpass
    username = ''
    password = ''
    if len(argv) > 1:
        username = argv[1]
    else:
        username = input('Username: ')
    password = getpass.getpass('Password: ')
    client = login(username, password)
    print("Successfully logged in as", username)
    print("Starting zuck...")
    curses.wrapper(chat)
    client.logout()
    print("Successfully logged out.")
